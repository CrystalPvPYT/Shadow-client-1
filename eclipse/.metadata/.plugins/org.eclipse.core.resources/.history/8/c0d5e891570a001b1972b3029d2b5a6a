package me.mystra.module.combat;

import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.monster.EntityMob;
import net.minecraft.entity.monster.EntitySlime;
import net.minecraft.entity.passive.EntityAnimal;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemSword;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.client.C07PacketPlayerDigging;
import net.minecraft.network.play.client.C08PacketPlayerBlockPlacement;
import net.minecraft.network.play.client.C0BPacketEntityAction;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.MathHelper;

import java.io.*;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import me.mystra.Mystra;
import me.mystra.clickgui.settings.Setting;
import me.mystra.event.EventTarget;
import me.mystra.event.events.EventPreMotionUpdate;
import me.mystra.event.events.EventUpdate;
import me.mystra.module.Category;
import me.mystra.module.Module;
import me.mystra.utils.TimeHelper;

public class Aura extends Module {

    private List<EntityLivingBase> loaded = new ArrayList<>();
    private List<EntityLivingBase> possibleTargets = new ArrayList<EntityLivingBase>();
    private int currentTarget;
    private EntityLivingBase target;
    private TimeHelper time = new TimeHelper();


    public Aura() {
        super("Aura", 0, Category.COMBAT);
        
        ArrayList<String> options = new ArrayList<>();
        options.add("Switch");
        options.add("Single");
        
        Mystra.instance.settingsManager.rSetting(new Setting("Aura Mode", this, "Switch", options));
        
        //BOOLEANS
        Mystra.instance.settingsManager.rSetting(new Setting("Teams", this, false));
        Mystra.instance.settingsManager.rSetting(new Setting("Invisibles", this, false));
        Mystra.instance.settingsManager.rSetting(new Setting("Players", this, true));
        Mystra.instance.settingsManager.rSetting(new Setting("Animals", this, false));
        Mystra.instance.settingsManager.rSetting(new Setting("Monsters", this, false));
        Mystra.instance.settingsManager.rSetting(new Setting("AutoBlock", this, false));
        
        //FLOATS
        Mystra.instance.settingsManager.rSetting(new Setting("FOV", this, 360, 1, 360, true));
        Mystra.instance.settingsManager.rSetting(new Setting("Delay", this, 75, 1, 1000, true));
        Mystra.instance.settingsManager.rSetting(new Setting("Ticks", this, 16, 0, 1000, true));
        Mystra.instance.settingsManager.rSetting(new Setting("Range", this, 4.4F, 3.0F, 7.0F, true));
    }

    private List<EntityLivingBase> getNearby(float range) {
        List<EntityLivingBase> nearby = new ArrayList<EntityLivingBase>();
        for (Entity e : mc.thePlayer.getEntityWorld().loadedEntityList) {
            if (Mystra.instance.getFriendManager().isFriend(getName())) {
                continue;
            }
            if (!(e instanceof EntityLivingBase)
                    || e.getName().equalsIgnoreCase(mc.thePlayer.getName())
                    || !e.isEntityAlive() || mc.thePlayer.getDistanceToEntity(e) > range
                    || e == mc.thePlayer) {
                continue;
            }
            nearby.add((EntityLivingBase) e);
        }
        nearby.sort((o1, o2) -> Float.compare(mc.thePlayer.getDistanceToEntity(o1),
                mc.thePlayer.getDistanceToEntity(o2)));
        return nearby;
    }

    @EventTarget
    public void onPre(EventPreMotionUpdate event) {
    	String mode = Mystra.instance.settingsManager.getSettingByName("Aura Mode").getValString();

        if(mode.equalsIgnoreCase("Single")) {
                target = getBestEntity();
                boolean blockCheck1 = (Mystra.instance.settingsManager.getSettingByName("AutoBlock").getValBoolean() && mc.thePlayer.inventory.getCurrentItem() != null && mc.thePlayer.inventory.getCurrentItem().getItem() != null && mc.thePlayer.inventory.getCurrentItem().getItem() instanceof ItemSword);
                if (target != null) {
                    event.setYaw(getRotations(target)[0]);
                    event.setPitch(getRotations(target)[1]);
                } else {
                    if (target != null && blockCheck1 && mc.thePlayer.getDistanceToEntity(target) < Mystra.instance.settingsManager.getSettingByName("Range").getValDouble())
                        mc.playerController.sendUseItem(mc.thePlayer, mc.theWorld, mc.thePlayer.inventory.getCurrentItem());
                    if (mc.thePlayer.isBlocking())
                        mc.thePlayer.sendQueue.addToSendQueue(new C07PacketPlayerDigging(C07PacketPlayerDigging.Action.RELEASE_USE_ITEM, new BlockPos(0, 0, 0), EnumFacing.fromAngle(-255.0D)));
                    if (target != null && time.isDelayComplete((float) Mystra.instance.settingsManager.getSettingByName("Range").getValDouble())) {
                        attack(target);
                        if (mc.thePlayer.isBlocking())
                            mc.thePlayer.sendQueue.addToSendQueue(new C08PacketPlayerBlockPlacement(new BlockPos(0, 0, 0), 255, mc.thePlayer.inventory.getCurrentItem(), 0.0F, 0.0F, 0.0F));
                        time.reset();
                    }
                }
        	}
        if(mode.equalsIgnoreCase("Switch")) {
                target = getBestEntity();
                boolean blockCheck = (Mystra.instance.settingsManager.getSettingByName("AutoBlock").getValBoolean() && mc.thePlayer.inventory.getCurrentItem() != null && mc.thePlayer.inventory.getCurrentItem().getItem() != null && mc.thePlayer.inventory.getCurrentItem().getItem() instanceof ItemSword);
                if (target != null) {
                    event.setYaw(getRotations(possibleTargets.get(currentTarget))[0]);
                    event.setPitch(getRotations(possibleTargets.get(currentTarget))[1]);
                } else {
                    if (target != null && blockCheck && mc.thePlayer.getDistanceToEntity(target) < Mystra.instance.settingsManager.getSettingByName("Range").getValDouble())
                        mc.playerController.sendUseItem(mc.thePlayer, mc.theWorld, mc.thePlayer.inventory.getCurrentItem());
                    if (mc.thePlayer.isBlocking())
                        mc.thePlayer.sendQueue.addToSendQueue(new C07PacketPlayerDigging(C07PacketPlayerDigging.Action.RELEASE_USE_ITEM, new BlockPos(0, 0, 0), EnumFacing.fromAngle(-255.0D)));
                    if (target != null && time.isDelayComplete((float) Mystra.instance.settingsManager.getSettingByName("Delay").getValDouble())) {
                        this.possibleTargets = getNearby((float) Mystra.instance.settingsManager.getSettingByName("Range").getValDouble());

                        if (!this.possibleTargets.isEmpty()) {
                            if (this.currentTarget >= this.possibleTargets.size()) {
                                this.currentTarget = 0;
                            }
                            this.possibleTargets = this.sort(this.possibleTargets);
                            this.target = this.possibleTargets.get(currentTarget);
                        }
                        if (time.isDelayComplete(500)) {
                            this.currentTarget++;
                            time.reset();
                        }
                        attack(possibleTargets.get(currentTarget));
                        if (mc.thePlayer.isBlocking())
                            mc.thePlayer.sendQueue.addToSendQueue(new C08PacketPlayerBlockPlacement(new BlockPos(0, 0, 0), 255, mc.thePlayer.inventory.getCurrentItem(), 0.0F, 0.0F, 0.0F));
                        time.reset();
                    }
                }
        	}
    	}

    public List<EntityLivingBase> sort(List<EntityLivingBase> possibleTargets2) {
        possibleTargets2.sort((target1, target2) -> {
            double distance1 = angleDistanceYawNoAbs(target1);
            double distance2 = angleDistanceYawNoAbs(target2);
            return distance1 < distance2 ? 1 : distance1 == distance2 ? 0 : -1;
        });
        return possibleTargets2;
    }

    public int angleDistanceYawNoAbs(Entity entity) {
        float[] neededRotations = getRotationsNeeded(entity);
        if (neededRotations != null) {
            float neededYaw = neededRotations[0] - mc.thePlayer.rotationYaw;
            return (int) neededYaw;
        }
        return -1;
    }

    public float[] getRotationsNeeded(final Entity entity) {
        if (entity == null) {
            return null;
        }
        final double xSize = entity.posX - mc.thePlayer.posX;
        final double ySize = entity.posY + entity.getEyeHeight() / 2.0
                - (mc.thePlayer.posY + mc.thePlayer.getEyeHeight());
        final double zSize = entity.posZ - mc.thePlayer.posZ;
        final double theta = MathHelper.sqrt_double(xSize * xSize + zSize * zSize);
        final float yaw = (float) (Math.atan2(zSize, xSize) * 180.0 / 3.141592653589793) - 90.0f;
        final float pitch = (float) (-(Math.atan2(ySize, theta) * 180.0 / 3.141592653589793));
        return new float[]{
                (mc.thePlayer.rotationYaw + MathHelper.wrapAngleTo180_float(yaw - mc.thePlayer.rotationYaw)) % 360.0f,
                (mc.thePlayer.rotationPitch + MathHelper.wrapAngleTo180_float(pitch - mc.thePlayer.rotationPitch))
                        % 360.0f};
    }

    private EntityLivingBase getBestEntity() {
        if (loaded != null) {
            loaded.clear();
        }
        for (Object object : mc.theWorld.loadedEntityList) {
            if (object instanceof EntityLivingBase) {
                EntityLivingBase e = (EntityLivingBase) object;
                if (isValid(e)) {
                    loaded.add(e);
                }
            }
        }
        assert loaded != null;
        if (loaded.isEmpty()) {
            return null;
        }
        loaded.sort((o1, o2) -> {
            float[] rot1 = getRotations(o1);
            float[] rot2 = getRotations(o2);
            return Float.compare((mc.thePlayer.rotationYaw - rot1[0]) % 0,
                    (mc.thePlayer.rotationYaw - rot2[0]) % 0);
        });
        return loaded.get(0);
    }


    public boolean isValid(EntityLivingBase entity) {
        if (Mystra.instance.settingsManager.getSettingByName("Teams").getValBoolean() && entity != null) {
            final String name = entity.getDisplayName().getFormattedText();
            final StringBuilder append = new StringBuilder().append("§");
            if (name.startsWith(append.append(mc.thePlayer.getDisplayName().getFormattedText().charAt(1)).toString())) {
                return false;
            }
        }
        return (entity != null
                && entity.isEntityAlive()
                && isEntityInFov(entity, Mystra.instance.settingsManager.getSettingByName("FOV").getValDouble())
                && entity != mc.thePlayer
                && (entity instanceof EntityPlayer
                && Mystra.instance.settingsManager.getSettingByName("Players").getValBoolean())
                || entity instanceof EntityAnimal
                && Mystra.instance.settingsManager.getSettingByName("Animals").getValBoolean()
                || entity instanceof EntityMob ||
                entity instanceof EntitySlime
                        && Mystra.instance.settingsManager.getSettingByName("Monsters").getValBoolean())
                && entity.getDistanceToEntity(mc.thePlayer) <= Mystra.instance.settingsManager.getSettingByName("Range").getValDouble()
                && (!entity.isInvisible()
                || Mystra.instance.settingsManager.getSettingByName("Invisibles").getValBoolean())
                && entity.ticksExisted > Mystra.instance.settingsManager.getSettingByName("Ticks").getValDouble() && !Mystra.instance.getFriendManager().isFriend(getName());
    }

    private boolean isEntityInFov(final EntityLivingBase entity, double angle) {
        angle *= 0.5;
        final double angleDifference = getAngleDifference(mc.thePlayer.rotationYaw, getRotations(entity)[0]);
        return (angleDifference > 0.0 && angleDifference < angle)
                || (-angle < angleDifference && angleDifference < 0.0);
    }

    private void attack(EntityLivingBase entity) {
        final float sharpLevel = EnchantmentHelper.func_152377_a(mc.thePlayer.getHeldItem(), mc.thePlayer.getCreatureAttribute());
        final boolean wasSprinting = mc.thePlayer.isSprinting();
        if (sharpLevel > 0) {
            mc.thePlayer.onEnchantmentCritical(entity);
        }
        if (wasSprinting)
            mc.getNetHandler().addToSendQueue(new C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.STOP_SPRINTING));

        mc.thePlayer.swingItem();
        mc.thePlayer.sendQueue.addToSendQueue((Packet) new C02PacketUseEntity(entity, C02PacketUseEntity.Action.ATTACK));

        if (wasSprinting)
            mc.getNetHandler().addToSendQueue(new C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.START_SPRINTING));
        mc.thePlayer.setSprinting(wasSprinting);
    }

    @Override
    public void onEnable() {
        super.onEnable();
        currentTarget = 0;
    }

    private float[] getRotations(Entity entity) {

        double diffX = entity.posX - mc.thePlayer.posX;
        double diffZ = entity.posZ - mc.thePlayer.posZ;
        double diffY;
        if ((entity instanceof EntityLivingBase)) {
            EntityLivingBase elb = (EntityLivingBase) entity;
            diffY = elb.posY
                    + (elb.getEyeHeight() - 0.4)
                    - (mc.thePlayer.posY + mc.thePlayer
                    .getEyeHeight());
        } else {
            diffY = (entity.boundingBox.minY + entity.boundingBox.maxY)
                    / 2.0D
                    - (mc.thePlayer.posY + mc.thePlayer
                    .getEyeHeight());
        }
        double dist = MathHelper.sqrt_double(diffX * diffX + diffZ * diffZ);
        float yaw = (float) (Math.atan2(diffZ, diffX) * 180.0D / Math.PI) - 90.0F;
        float pitch = (float) -(Math.atan2(diffY, dist) * 180.0D / Math.PI);

        return new float[]{yaw, pitch};
    }

    private float getAngleDifference(float direction, float rotationYaw) {
        float phi = Math.abs(rotationYaw - direction) % 360;
        return phi > 180 ? 360 - phi : phi;
    }

}
