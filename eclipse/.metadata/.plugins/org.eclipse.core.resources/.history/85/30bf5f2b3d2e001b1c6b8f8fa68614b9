package me.mystra.module.combat.killaura;

import java.util.ArrayList;

import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.util.MathHelper;
import net.minecraft.util.Vec3;

public class AuraUtils {
	
	public static double smoothAimSpeed = 2.5;
	public static ArrayList<EntityLivingBase> targets = new ArrayList<EntityLivingBase>();
	public static ArrayList<EntityLivingBase> blackList = new ArrayList<EntityLivingBase>();

	public static boolean hasEntity(Entity en) {
		if (en == null) {
			return false;
		}
		if (!AuraUtils.targets.isEmpty()) {
			for (EntityLivingBase en1 : AuraUtils.targets) {
				if (en1 == null) {
					continue;
				}
				if (en1.isEntityEqual(en)) {
					return true;
				}
			}
		}
		return false;
	}

	public static boolean blackEntity(Entity en) {
		if (en == null) {
			return false;
		}
		if (!AuraUtils.blackList.isEmpty()) {
			for (EntityLivingBase en1 : AuraUtils.blackList) {
				if (en1 == null) {
					continue;
				}
				if (en1.isEntityEqual(en)) {
					return true;
				}
			}
		}
		return false;
	}

	private static boolean disableAura = false;
	private static boolean reachExploit = false;
	private static int timercap = 15;
	private static double range = 7;
	private static boolean headsnap = false;
	private static double chargerange = 8.0;
	
	public static boolean getDisableAura() {
		return disableAura;
	}

	public static void setDisableAura(boolean disableAura) {
		AuraUtils.disableAura = disableAura;
	}

	public static void setReachExploit(boolean reachExploit) {
		AuraUtils.reachExploit = reachExploit;
	}

	public static boolean isReachExploit() {
		return reachExploit;
	}

	private static double packetTPRange = 10;

	public static double getPacketTPRange() {
		return packetTPRange;
	}

	public static void setPacketTPRange(double packetTPRange) {
		AuraUtils.packetTPRange = packetTPRange;
	}

	public static double getRange() {
		return range;
	}

	public static boolean getHeadsnap() {
		return headsnap;
	}

	public static int getAPS() {
		return timercap;
	}

	public static void setTimer(int set) {
		timercap = set;
	}

	public static void setRange(double value) {
		range = value;
	}

	public static void setHeadSnap(boolean selected) {
		headsnap = selected;
	}

	public static double getChargeRange() {
		return chargerange;
	}

	public static void setChargeRange(double chargerange) {
		AuraUtils.chargerange = chargerange;
	}

	public static double getSmoothAimSpeed() {
		return smoothAimSpeed;
	}

	public static void setSmoothAimSpeed(double smoothAimSpeed) {
		AuraUtils.smoothAimSpeed = smoothAimSpeed;
	}
	
	public static float[] getFacePos(Vec3 vec) {
		double diffX = vec.xCoord + 0.5 - Minecraft.getMinecraft().thePlayer.posX;
		double diffY = vec.yCoord + 0.5
				- (Minecraft.getMinecraft().thePlayer.posY + Minecraft.getMinecraft().thePlayer.getEyeHeight());
		double diffZ = vec.zCoord + 0.5 - Minecraft.getMinecraft().thePlayer.posZ;
		double dist = MathHelper.sqrt_double(diffX * diffX + diffZ * diffZ);
		float yaw = (float) (Math.atan2(diffZ, diffX) * 180.0D / Math.PI) - 90.0F;
		float pitch = (float) -(Math.atan2(diffY, dist) * 180.0D / Math.PI);
		return new float[] {
				Minecraft.getMinecraft().thePlayer.rotationYaw
						+ MathHelper.wrapAngleTo180_float(yaw - Minecraft.getMinecraft().thePlayer.rotationYaw),
				Minecraft.getMinecraft().thePlayer.rotationPitch
						+ MathHelper.wrapAngleTo180_float(pitch - Minecraft.getMinecraft().thePlayer.rotationPitch) };
	}
	
	public static float[] getFacePosEntity(Entity en) {
		if (en == null) {
			return new float[] { Minecraft.getMinecraft().thePlayer.rotationYawHead,
					Minecraft.getMinecraft().thePlayer.rotationPitch };
		}
		return getFacePos(new Vec3(en.posX - 0.5, en.posY + (en.getEyeHeight() - en.height / 1.5), en.posZ - 0.5));
	}

}
