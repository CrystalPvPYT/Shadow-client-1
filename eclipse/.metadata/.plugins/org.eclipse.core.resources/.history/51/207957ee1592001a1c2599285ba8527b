package me.mystra.module.movement;

import org.lwjgl.input.Keyboard;

import de.Hero.settings.Setting;
import me.mystra.Mystra;
import me.mystra.event.EventTarget;
import me.mystra.event.events.EventPreMotionUpdate;
import me.mystra.event.events.EventUpdate;
import me.mystra.module.Category;
import me.mystra.module.Module;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.block.BlockLiquid;
import net.minecraft.block.material.Material;
import net.minecraft.block.state.pattern.BlockHelper;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.passive.EntityPig;
import net.minecraft.item.ItemBlock;
import net.minecraft.item.ItemStack;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C09PacketHeldItemChange;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.MathHelper;
import net.minecraft.util.Vec3;

public class Scaffold extends Module {
	public class BlockData {
        public BlockPos position;
        public EnumFacing face;

        public BlockData(BlockPos position, EnumFacing face) {
            this.position = position;
            this.face = face;
        }
    }
	private BlockData target;
	private static boolean cooldown = false;
	
	public Scaffold() {
		super("Scaffold", Keyboard.KEY_G, Category.MOVEMENT);
		
		Mystra.instance.settingsManager.rSetting(new Setting("TowerSpeed", this, 0.37, 0.1, 10, false));
		Mystra.instance.settingsManager.rSetting(new Setting("Tower", this, false));
		
	}
	@EventTarget
	public void onUpdate(EventUpdate event) {
		BlockPos playerBlock = new BlockPos(mc.thePlayer.posX, mc.thePlayer.getEntityBoundingBox().minY, mc.thePlayer.posZ);
		if(mc.theWorld.isAirBlock(playerBlock.add(0, -1, 0))) {
			if(isValidBlock(playerBlock.add(0, -2, 0))) {
				if(Mystra.instance.settingsManager.getSettingByName("Tower").getValBoolean()) {
				if(mc.gameSettings.keyBindJump.pressed) {
					mc.thePlayer.motionY = Mystra.instance.settingsManager.getSettingByName("TowerSpeed").getValDouble();;
					mc.thePlayer.motionX = 0F;
					mc.thePlayer.motionZ = 0F;
					this.setName("Scaffold | &7Tower");
					}else {
						this.setName("Scaffold | &7Tower");
					}
				}
				setName("Scaffold");
				place(playerBlock.add(0, -2, 0), EnumFacing.UP);
                place(playerBlock.add(0, -1, 0), EnumFacing.UP);
			}else if(isValidBlock(playerBlock.add(-1, -1, 0))) {
				place(playerBlock.add(0, -1, 0), EnumFacing.EAST);
			}else if(isValidBlock(playerBlock.add(1, -1, 0))) {
				place(playerBlock.add(0, -1, 0), EnumFacing.WEST);
			}else if(isValidBlock(playerBlock.add(0, -1, -1))) {
				place(playerBlock.add(0, -1, 0), EnumFacing.SOUTH);
			}else if(isValidBlock(playerBlock.add(0, -1, 1))) {
				place(playerBlock.add(0, -1, 0), EnumFacing.NORTH);
				
			}else if(isValidBlock(playerBlock.add(1, -1, 1))) {
				if(isValidBlock(playerBlock.add(0, -1, 1))) {
					place(playerBlock.add(0, -1, 1), EnumFacing.NORTH);
				}
				place(playerBlock.add(1, -1, 1), EnumFacing.EAST);
				
			}else if(isValidBlock(playerBlock.add(-1, -1, 1))) {
				if(isValidBlock(playerBlock.add(-1, -1, 0))) {
					place(playerBlock.add(0, -1, 1), EnumFacing.WEST);
				}
				place(playerBlock.add(-1, -1, 1), EnumFacing.SOUTH);
				
			}else if(isValidBlock(playerBlock.add(-1, -1, -1))) {
				if(isValidBlock(playerBlock.add(0, -1, -1))) {
					place(playerBlock.add(0, -1, -1), EnumFacing.SOUTH);
				}
				place(playerBlock.add(-1, -1, 1), EnumFacing.WEST);
				
			}else if(isValidBlock(playerBlock.add(1, -1, -1))) {
				if(isValidBlock(playerBlock.add(1, -1, 0))) {
					place(playerBlock.add(1, -1, 0), EnumFacing.EAST);
				}
				place(playerBlock.add(1, -1, -1), EnumFacing.NORTH);
			}
		}
	}
	
	private boolean isValidBlock(BlockPos pos) {
		Block b = mc.theWorld.getBlockState(pos).getBlock();
		return (!(b instanceof BlockLiquid)) && (b.getMaterial() != Material.air);
	}
	
	private void place(BlockPos pos, EnumFacing face) {
		cooldown = true;
		if(face == EnumFacing.UP) {
			pos = pos.add(0, -1, 0);
		}else if(face == EnumFacing.NORTH) {
			pos = pos.add(0, 0, 1);
		}else if(face == EnumFacing.EAST) {
			pos = pos.add(-1, 0, 0);
		}else if(face == EnumFacing.SOUTH) {
			pos = pos.add(0, 0, -1);
		}else if(face == EnumFacing.WEST) {
			pos = pos.add(1, 0, 0);
		}
		if (mc.thePlayer.getHeldItem() == null || !(mc.thePlayer.getHeldItem().getItem() instanceof net.minecraft.item.ItemBlock)) {
			for (int i = 0; i < 9; i++) {
				ItemStack item = mc.thePlayer.inventory.getStackInSlot(i);
				if (item != null && item.getItem() instanceof net.minecraft.item.ItemBlock) {
					int last = mc.thePlayer.inventory.currentItem;
					mc.thePlayer.sendQueue.addToSendQueue(new C09PacketHeldItemChange(i - 0));
		            mc.thePlayer.inventory.currentItem = i - 0;
		            mc.playerController.updateController();
					mc.playerController.onPlayerRightClick(mc.thePlayer, mc.theWorld, mc.thePlayer.getHeldItem(), pos, face, new Vec3(0.5D, 0.5D, 0.5D));
					mc.thePlayer.swingItem();
		            mc.thePlayer.sendQueue.addToSendQueue(new C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem));
		            mc.thePlayer.inventory.currentItem = last;
		            mc.playerController.updateController();
        	}
		}
			double var4 = pos.getX() + 0.25D - mc.thePlayer.posX;
			double var6 = pos.getZ() + 0.25D - mc.thePlayer.posZ;
			double var8 = pos.getY() + 0.25D - (mc.thePlayer.posY + mc.thePlayer.getEyeHeight());
			double var14 = MathHelper.sqrt_double(var4 * var4 + var6 * var6);
			float yaw = (float)(Math.atan2(var6, var4) * 180.0D / 3.141592653689793D) - 90.0F;
			float pitch = (float)-(Math.atan2(var8, var14) * 180.0D / 3.141592653689793D);
			int ticks = 0;
			ticks++;
			if(ticks >= 1000) {
				ticks = 0;
				mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, yaw, pitch, mc.thePlayer.onGround));
			}
		}
		if((mc.thePlayer.getHeldItem() != null) && ((mc.thePlayer.getHeldItem().getItem() instanceof ItemBlock))) {
			mc.playerController.onPlayerRightClick(mc.thePlayer, mc.theWorld, mc.thePlayer.getHeldItem(), pos, face, new Vec3(0.5D, 0.5D, 0.5D));
			mc.thePlayer.swingItem();
			double var4 = pos.getX() + 0.25D - mc.thePlayer.posX;
			double var6 = pos.getZ() + 0.25D - mc.thePlayer.posZ;
			double var8 = pos.getY() + 0.25D - (mc.thePlayer.posY + mc.thePlayer.getEyeHeight());
			double var14 = MathHelper.sqrt_double(var4 * var4 + var6 * var6);
			float yaw = (float)(Math.atan2(var6, var4) * 180.0D / 3.141592653689793D) - 90.0F;
			float pitch = (float)-(Math.atan2(var8, var14) * 180.0D / 3.141592653689793D);
			int ticks = 0;
			ticks++;
			if(ticks >= 1000) {
				ticks = 0;
				mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, yaw, pitch, mc.thePlayer.onGround));
			}
		}
	}
	@EventTarget
	public void onPre(EventPreMotionUpdate event) {
		 //BlockPos blockBelowPlayer = new BlockPos(mc.thePlayer.posX, mc.thePlayer.posY - 1, mc.thePlayer.posZ);
	     float[] values = getFacingRotations(target.position.getX(), target.position.getY(), target.position.getZ(), target.face);
	     event.setYaw((float) (values[0] + Math.random() * 2 - 1));
	     event.setPitch((float) (values[1] + Math.random() * 2 - 1));
	     mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C05PacketPlayerLook(event.getYaw(), event.getPitch(), false));
	}
	public BlockData getTarget(BlockPos pos) {
        EnumFacing[] orderedFacingValues = new EnumFacing[] {
                EnumFacing.UP,
                EnumFacing.EAST,
                EnumFacing.NORTH,
                EnumFacing.WEST,
                EnumFacing.SOUTH,
                EnumFacing.DOWN
        };
        for (EnumFacing facing : orderedFacingValues) {
            BlockPos alteredPos = pos.add(facing.getOpposite().getDirectionVec());

            if (!mc.theWorld.getBlockState(alteredPos).getBlock().isReplaceable(mc.theWorld, alteredPos) && !(mc.theWorld.getBlockState(alteredPos).getBlock() instanceof BlockLiquid) && !(mc.theWorld.getBlockState(alteredPos).getBlock() instanceof BlockAir)) {
                return new BlockData(alteredPos, facing);
            }
        }
		return null;
	}
	@Override
    public void onEnable() {
        super.onEnable();
    }
    @Override
    public void onDisable() {
        super.onDisable();
    }
    private float[] getFacingRotations(int paramInt1, int paramInt2, int paramInt3, EnumFacing paramEnumFacing) {
        EntityPig localEntityPig = new EntityPig(Scaffold.mc.theWorld);
        localEntityPig.posX = (double)paramInt1 + 0.5;
        localEntityPig.posY = (double)paramInt2 + 0.5;
        localEntityPig.posZ = (double)paramInt3 + 0.5;
        localEntityPig.posX += (double)paramEnumFacing.getDirectionVec().getX() * 0.25;
        localEntityPig.posY += (double)paramEnumFacing.getDirectionVec().getY() * 0.25;
        localEntityPig.posZ += (double)paramEnumFacing.getDirectionVec().getZ() * 0.25;
        return jdMethod_double(localEntityPig);
    }
    private static float[] jdMethod_double(EntityLivingBase paramEntityLivingBase) {
        double d1 = paramEntityLivingBase.posX - Scaffold.mc.thePlayer.posX;
        double d2 = paramEntityLivingBase.posY + (double)paramEntityLivingBase.getEyeHeight() - (Scaffold.mc.thePlayer.posY + (double)Scaffold.mc.thePlayer.getEyeHeight());
        double d3 = paramEntityLivingBase.posZ - Scaffold.mc.thePlayer.posZ;
        double d4 = MathHelper.sqrt_double(d1 * d1 + d3 * d3);
        float f1 = (float)(Math.atan2(d3, d1) * 180.0 / 3.141592653589793) - 90.0f;
        float f2 = (float)(- Math.atan2(d2, d4) * 180.0 / 3.141592653589793);
        return new float[]{f1, f2};
    }
}